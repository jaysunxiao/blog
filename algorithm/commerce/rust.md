### rust历史

任何一门新技术的兴起，都是为了解决一个问题。自操作系统诞生以来，系统级主流编程语言，从汇编语言到 C++，已经发展了近 50 个年头，但依然存在两个难题：

- 很难编写内存安全的代码。
- 很难编写线程安全的代码

这两个难题存在的本质原因是C/C++属于类型不安全的语言，它们薄弱的内存管理机制导致了很多常见的漏洞。

### rust优点

要特点有以下几方面：

- 系统级语言
- 无GC
- 基于LLVM
- 内存安全
- 强类型+静态类型
- 混合编程范式
- 零成本抽象
- 线程安全

- 互联网发展至今，性能问题已经不再是其发展瓶颈，安全问题才是阻碍其发展的“重疾”。

```
Rust语言解决了内存安全和并发安全的问题，可以极大地提升软件的质量。
Rust的诞生为业界提供了一个除C和C++之外的更好的选择。
因为Rust是对安全、并发和性能都很看重的语言，它可以用于嵌入式系统、操作系统、网络服务等底层系统，但它并不局限于此，它还可以用
于开发上层Web应用、游戏引擎和机器学习，甚至基于WebAssembly 技术还可以开发前端组件。因为高的安全性和不逊于C/C++的性能，Rust
也被应用于新的前沿领域，比如区块链技术。
```

### 类型安全，内存安全

只有当程序访问未定义内存的时候才会产生内存错误。一般来说， 发生以下几种情况就会产生内存错误：

- 没有空指针
- 使用未初始化内存。
- 释放后使用，也就是使用悬垂指针。
- 缓冲区溢出，比如数组越界。
- 非法释放已经释放过的指针或未分配的指针，也就是重复释放。
- 借用、生命周期
- 默认不可变
- 表达式，高阶函数，模式匹配
- 代数数据类型，泛型，trait和关联类型，本地类型推导

这些情况之所以会产生内存错误，是因为它们都访问了未定义内存。为了保证内存安全，Rust语言建立了严格的安全内存管理模型：

- 所有权系统。

```
每个被分配的内存都有一个独占其所有权的指针。 只有当该指针被销毁时，其对应的内存才能随之被释放。 
```

- 借用和生命周期。

```
每个变量都有其生命周期，一旦超出生命周期，变量就会被自动释放。
如果是借用，则可以通过标记生命周期参数 供编译器检查的方式，防止出现悬垂指针，也就是释放后使用的情况。
其中所有权系统还包括了从现代C++那里借鉴的RAII机制，这是 Rust无GC但是可以安全管理内存的基石。
``` 

借助类型系统的强大，Rust编译器可以在编译期对类型进行检查， 看其是否满足安全内存模型，在编译期就能发现内存不安全问题，有效 地阻止未定义行为的发生。

内存安全的Bug和并发安全的Bug产生的内在原因是相同的，都是因为内存的不正当访问而造成的。 同样，利用装载了所有权的强大类型系统，Rust还解决了并发安全的问题。
Rust编译器会通过静态检查分析，在编译期就检查出多线程并发代码中所有的数据竞争问题。

rust引入了强大的类型系统和所有权系统，不仅保证内存安全，还保证了并发安全，同时还不会牺牲性能。

### 异常

- 为了保证程序的健壮性，Rust重新审视了错误处理机制。

日常开发中一般有三类非正常情况：失败、错误和异常。但是像C语言这种面向过程的语言，开发者只能通过返回值、goto等语句进行错误处理，并且
没有统一的错误处理机制。而C++和Java这种高级语言虽然引入了异常处理机制，但没有专门提供能够有效区分正常逻辑和错误逻辑的语法，
而只是统一全局进行处理，导致开发者只能将所有的非正常情况都当作异常去处理，这样不利于健壮系统的开发。并且异常处理还会带来比较大的性能开销。

Rust语言针对这三类非正常情况分别提供了专门的处理方式，让开发者可以分情况去选择。

- 对于失败的情况，可以使用断言工具。
- 对于错误，Rust提供了基于返回值的分层错误处理方式，比如Option＜T＞可以用来处理可能存在空值的情况，而 Result＜T＞就专门用来处理可以被合理解决并需要传播的错误。
- 对于异常，Rust将其看作无法被合理解决的问题，提供了线程恐 慌机制，在发生异常的时候，线程可以安全地退出。

通过这样精致的设计，开发者就可以从更细的粒度上对非正常情况进行合理处理，最终编写出更加健壮的系统。

### rust架构

![Image text](image/rust00.png)
