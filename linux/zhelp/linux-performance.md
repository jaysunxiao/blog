# 一、Linux服务器性能排查

## 1.cpu负载情况，因为所有的系统负载最后都会反映在cpu的指标上

- uptime，查看cpu的负载情况

```
每个cpu的核都维护了一个运行队列，系统的load主要由运行队列来决定。
假设一个cpu有8个核，运行的应用程序启动了16个线程，并且这16个线程都处于运行状态，那么在平均分配的情况下，每个cpu的运行队列中就有2个线程在运行。
假设这种情况维持了一分钟，那么一分钟内的系统load值就为2。一般load值不大于3，我们就认为它的负载是正常的，大于了3就要想办法降低系统的负载。

14:47:23 up 109 days,  4:11,  1 user,  load average: 0.00, 0.01, 0.05
上面分别是1分钟，5分钟，15分钟内系统的load值。
```

- top

```
cpu的时间消耗主要在，
用户进程（us，user），
内核进程（sy，system），
Nice时间（ni，nice time，表示系统在调整进程优先级所花费的时间），
空闲时间（id，idel time，表示系统处于空闲期，等待进程运行，这个过程月低月好，低了说明应用火了），
等待时间（wa，waiting time，表示cpu在等待IO操作所花费的时间，系统不应该花费大量的时间进行等待，否则便是有某个地方设计不合理），
硬件中断时间（hi，hard interrupt time，表示系统硬件中断所占用的时间），
软件中断时间（si，soft interrupt time，表示系统软件中断所占用的时间），
丢失时间（st，steal time，在硬件虚拟化开始流行过后操作系统新增的一列）

按1，可以查看到每个核的cpu利用率；
按shift+h，可以按照线程来查看cpu的消耗情况，这一点对于Java应用来说非常有用，这个时候pid就会变成线程号，会把进程的所有线程号显示出来
按shift+m，根据内存排序，默认从大到小
按shift+p，根据CPU使用排序，默认从大到小

jps查看进程id后，可以用top -p xxx，查看指定java进程的cpu使用情况，这一点对于Java应用来说也非常有用

top - 14:47:15 up 109 days,  4:10,  1 user,  load average: 0.00, 0.01, 0.05
Tasks:  89 total,   1 running,  88 sleeping,   0 stopped,   0 zombie
%Cpu(s):  0.0 us,  0.0 sy,  0.0 ni,  100.0 id,  0.0 wa,  0.0 hi,  0.0 si,  0.0 st
KiB Mem :  7733220 total,  6330008 free,   547588 used,   855624 buff/cache
KiB Swap:        0 total,        0 free,        0 used.  6916052 avail Mem 

```

- pstack pid | jstack pid，可以查看线程相关信息
- ps -ef，列出目前所有的正在内存当中的程序进程，带有<defunct>字样的是僵尸进程
- mpstat -P ALL 1，每秒输出一次每个cpu占用情况
- pidstat 1，每秒输出一次进程的CPU占用率，该命令会持续输出

## 2.磁盘情况

- df -h

```
如果磁盘没有足够的剩余空间，正常的日志写入及系统IO都将无法进行
```

- iostat -xz 2 6，每2秒统计一次，一共输出6次次io情况

```
r/s, w/s, rkB/s, wkB/s：分别表示每秒读写次数和每秒读写数据量（千字节）。读写量过大，可能会引起性能问题。
await：IO操作的平均等待时间，单位是毫秒。这是应用程序在和磁盘交互时，需要消耗的时间，包括IO等待和实际操作的耗时。如果这个数值过大，可能是硬件设备遇到了瓶颈或者出现故障。
avgqu-sz：向设备发出的请求平均数量。如果这个数值大于1，可能是硬件设备已经饱和（部分前端硬件设备支持并行写入）。
%util：设备利用率。这个数值表示设备的繁忙程度，经验值是如果超过60，可能会影响IO性能（可以参照IO操作平均等待时间）。如果到达100%，说明硬件设备已经饱和。

如果显示的是逻辑设备的数据，那么设备利用率不代表后端实际的硬件设备已经饱和。值得注意的是，即使IO性能不理想，也不一定意味这应用程序性能会不好，可以利用诸如预读取、写缓存等策略提升应用性能。
```

## 3.内存情况

- free -m，内存使用情况

```
对于应用来说，更值得关注的应该是虚拟内存swap的消耗，swap内存使用过多，表示物理内存不够用了。
```

## 4.网络情况

- sar -n DEV 1，每秒输出一次网卡的吞吐量，yum install sysstat

```
sar命令在这里可以查看网络设备的吞吐率。在排查性能问题时，可以通过网络设备的吞吐量，判断网络设备是否已经饱和。

03:25:24 PM     IFACE   rxpck/s   txpck/s    rxkB/s    txkB/s   rxcmp/s   txcmp/s  rxmcst/s
03:25:25 PM      eth0      3.00      3.00      0.20      0.92      0.00      0.00      0.00
03:25:25 PM        lo      0.00      0.00      0.00      0.00      0.00      0.00      0.00


lo表示本地回环网络，而eth0表示网卡。
rxpck/s表示每秒接收的数据包数量
txpck/s表示每秒发出的数据包数量
rxkB/s表示每秒接收到的字节数
txkB/s表示每秒发送的字节数
rxcmp/s表示每秒发送的压缩包的数量
txcmp/s表示每秒发送的压缩包的数量
rxmcst/s表示每秒收到的广播包数量
```

- iftop -i eth0 -n -P，测量通过每一个套接字连接传输的数据，当看到流量比较大的端口27017传输后，使用下个命令查看端口所在的进程

```
中间的<= =>这两个左右箭头，表示的是流量的方向。

TX：发送流量
RX：接收流量
TOTAL：总流量
cum：运行iftop到目前时间的总流量
peak：流量峰值
rates：分别表示过去 2s 10s 40s 的平均流量
```

- netstat -anp | grep 27017

## 5.系统日志

- dmesg | tail -n 20，输出系统日志的最后20行

```
Linux系统常见的日志文件，系统所有的日志都在/var/log下
路径1：/var/log/messages：记录 Linux 内核消息及各种应用程序的公共日志信息
路径2：/var/log/cron：记录 crond 计划任务产生的事件信息
路径3：/var/log/dmesg：记录 Linux 操作系统在引导过程中的各种事件信息
路径4：/var/log/maillog：记录进入或发出系统的电子邮件活动
路径5：/var/log/lastlog：记录每个用户最近的登录事件
路径6：/var/log/secure：记录用户认证相关的安全事件信息
路径7：/var/log/wtmp：记录每个用户登录、注销及系统启动和停机事件
路径8：/var/log/btmp：记录失败的、错误的登录尝试及验证事件
```

- vmstat 1，每秒输出一次系统核心指标

```
r：等待在CPU资源的进程数。这个数据比平均负载更加能够体现CPU负载情况，数据中不包含等待IO的进程。如果这个数值大于机器CPU核数，那么机器的CPU资源已经饱和。
free：系统可用内存数（以千字节为单位），如果剩余内存不足，也会导致系统性能问题。下文介绍到的free命令，可以更详细的了解系统内存的使用情况。
si，so：交换区写入和读取的数量。如果这个数据不为0，说明系统已经在使用交换区（swap），机器物理内存已经不足。
us, sy, id, wa, st：这些都代表了CPU时间的消耗，它们分别表示用户时间（user）、系统（内核）时间（sys）、空闲时间（idle）、IO等待时间（wait）和被偷走的时间（stolen，一般被其他虚拟机消耗）。

一般情况下，如果用户时间和系统时间相加非常大，CPU出于忙于执行指令。如果IO等待时间很长，那么系统的瓶颈可能在磁盘IO。
```
