#事务

##一、命令
```
select @@tx_isolation           #查看当前会话隔离级别
select @@global.tx_isolation    #查看系统当前隔离级别
```

##二、事务的四个特性
- 四个基本要素（acid）：原子性、一致性、隔离性、持久性
1. 原子性(Actomicity)：整个事务中的操作要么全完成，要么全部不完成，不能滞留在中间某个环节，事务在执行过程发生错误，会被回滚（Rollback）到事务开始前的状态，就像没执行过一样
2. 一致性(Consistent)：在事务开始和结束之后，数据库的完整性约束没有被破坏
3. 隔离性(Isolation):使事务在给定的时间内执行的唯一操作，为了防止事务之间的混淆，必须串行化或序列化请求，使得在同一时间内仅有一个请求用于同一数据
4. 持久性(Durable):在事务完成以后，该事务所对数据库所做的更改持久保存到数据库之中，并不会被回滚

##三、事务的隔离级别
```
脏读（dirty read）：一个事务在对一条数据进行修改，在事务完成并提交前，记录就处于不一致的状态，这是另外一个事务也来读取同一条记录，
    如果不加以控制，第二个事务读取了这些“脏”数据，并据此做进一步处理，就会产生未提交数据的依关系
    
不可重复读（non-repeatable read）:一个事务在读取某些数据后的某个时间在，再次读取的时候，发现数据发生改变，或者某些记录被删除了

幻读（phantom read）:['fæntəm]一个事务按相同的查询条件重复读取以前检索过的数据，却发现了其它事务插入了满足其查询条件的新数据
    幻读指的是一个事务在前后两次查询同一个范围的时候，后一次查询看到了前一次查询没有看到的行。


隔离级别	                            读取数据一致性	        脏读	  不可重复读	   幻读
未提交读(Read uncommitted)	最低级别，只能保证读取不损坏数据	是	    是	        是
已提交读（Read committed）	        语句级	                否	    是	        是
可重复读（Repeatable read）	        事务级	                否	    否	        是
可序列化（Serializable）	            最高级别，事务级	        否	    否	        否

读未提交是指，一个事务还没提交时，它做的变更就能被别的事务看到。
读提交是指，一个事务提交之后，它做的变更才会被其他事务看到。
可重复读是指，一个事务执行过程中看到的数据，总是跟这个事务在启动时看到的数据是一致的。当然在可重复读隔离级别下，未提交变更对其他事务也是不可见的。
串行化，顾名思义是对于同一行记录，“写”会加“写锁”，“读”会加“读锁”。当出现读写锁冲突的时候，后访问的事务必须等前一个事务执行完成，才能继续执行。

在实现上，数据库里面会创建一个视图，访问的时候以视图的逻辑结果为准。
在“可重复读”隔离级别下，这个视图是在事务启动时创建的，整个事务存在期间都用这个视图。
在“读提交”隔离级别下，这个视图是在每个 SQL 语句开始执行的时候创建的。
这里需要注意的是，“读未提交”隔离级别下直接返回记录上的最新值，没有视图概念；
而“串行化”隔离级别下直接用加锁的方式来避免并行访问。

你隔离得越严实，效率就会越低。因此很多时候，我们都要在二者之间寻找一个平衡点。MySql默认的是Read Committed。

```
- 用一个例子说明这几种隔离级别。假设数据表 T 中只有一列，其中一行的值为 1，下面是按照时间顺序执行两个事务的行为。
![Image text](image/mysql-transaction-0.png)
- 我们来看看在不同的隔离级别下，事务 A 会有哪些不同的返回结果，也就是图里面 V1、V2、V3 的返回值分别是什么。
    1. 若隔离级别是“读未提交”， 则 V1 的值就是 2。这时候事务 B 虽然还没有提交，但是结果已经被 A 看到了。因此，V2、V3 也都是 2。
    2. 若隔离级别是“读提交”，则 V1 是 1，V2 的值是 2。事务 B 的更新在提交后才能被 A 看到。所以， V3 的值也是 2。
    3. 若隔离级别是“可重复读”，则 V1、V2 是 1，V3 是 2。之所以 V2 还是 1，遵循的就是这个要求：事务在执行期间看到的数据前后必须是一致的。
    4. 若隔离级别是“串行化”，则在事务 B 执行“将 1 改成 2”的时候，会被锁住。直到事务 A 提交后，事务 B 才可以继续执行。所以从 A 的角度看， V1、V2 值是 1，V3 的值是 2。


##四、锁
- 全局锁：顾名思义，全局锁就是对整个数据库实例加锁。
```
MySQL 提供了一个加全局读锁的方法，命令是 Flush tables with read lock (FTWRL)。
全局锁的典型使用场景是，做全库逻辑备份。官方自带的逻辑备份工具是 mysqldump。
当 mysqldump 使用参数–single-transaction 的时候，导数据之前就会启动一个事务，来确保拿到一致性视图。
而由于 MVCC 的支持，这个过程中数据是可以正常更新的。
```
- 表级锁：每次操作都锁定在整张表，开销少，加锁块，不会出现死锁，锁定粒度大，发生锁冲突的概率最高，并发度最低。
```
表锁的语法是 lock tables … read/write。与 FTWRL 类似，可以用 unlock tables 主动释放锁，也可以在客户端断开的时候自动释放。
需要注意，lock tables 语法除了会限制别的线程的读写外，也限定了本线程接下来的操作对象。
```
- 行级锁:每次操作锁定一行数据，开销大，加锁慢，会出现死锁，锁定粒度小，发生锁冲突的概率最低，并发度最高，使用行级锁定的主要是InnoDB存储引擎。
```
MDL（metadata lock)，MDL 不需要显式使用，在访问一个表的时候会被自动加上。MDL 的作用是，保证读写的正确性。
在 InnoDB 事务中，行锁是在需要的时候才加上的，但并不是不需要了就立刻释放，而是要等到事务结束时才释放。这个就是两阶段锁协议。
```
- 页面锁：开销和加锁时间介于两者之间，会出现死锁，并发度一般
- 悲观锁：假定会发生并发冲突，屏蔽一切可能违反数据完整性的操作
- 乐观锁：假设不会发生并发冲突，只在提交操作时检查是否违反数据完整性
```
乐观锁更适合解决冲突概率极小的情况，而悲观锁则适合解决并发竞争激烈的情况，尽量使用行锁,缩小加锁粒度，以提高并发处理能力，即使加行锁的时间比表锁要长
```

##五、innodb的事务与日志实现方式
###1. 日志种类
  - 错误日志：记录出错信息，也记录一些警告或是正确的信息
  - 查询日志：记录所有对数据请求信息，不论是否得到正确执行
  - 慢查询日志：设置一个阈值，将运行时间超过该值的所有SQL语句都记录进去
  - 二进制日志：记录对数据库执行更改的所有操作
  
###2. 事务是如何通过日志实现的
```
事务日志是通过redo和innodb的存储引擎日志缓冲来实现的，当开始一个事务的时候，会记录该事务的lsn号。
当事务执行时，会往innodb存储引擎日志缓存里面插入事务日志，当事务提交时，必须将存储引擎的日志缓存写入磁盘，也就是写数据前，要先写日志
```

###3. 日志格式
- Row Level
```
Binary Log会记录成每一行数据被修改的形式，然后在Slave端再对相同的数据进行修改。
如果修改了表的结构，那么binlog日志记录的是重新创建表，在插入字段、update等操作语句，而不是的alter的动作。

优点：在Row Level模式下，Binnary Log可以不记录执行的Query语句的上下文相关信息，只要记录哪一行修改了，修改成什么样子。
Row Level会详细的记录下每一行数据的修改细节，而且不会出现某个特定情况下的存储过程，或Function，以及Trigger的调用和触发无法被正确复制问题。
 
缺点：产生大量的日志内容。
```

- Statment Level
```
每一条会修改的SQL语句都会记录到Master的Binnary中。Slave端在复制的时候，SQL线程会解析成和原来Master端执行过相同的SQL语句，并再次执行。

优点：首先，解决了Row Level下的缺点，不须要记录每一行的数据变化，减少了Binnary Log日志量，节约了IO成本，提高了性能。

缺点：由于它是记录的执行语句，为了让这些语句在Slave端也能正确执行。那么它还必须记录每条语句在执行时的一些相关信息，
即上下文信息，以保证所有语句在Slave端被执行的时候能够得到和在Master端执行时相同的结果。另外，由于MySQL发展比较快，很多新功能不断加入，
使得MySQL复制遇到了不小的挑战，复制时设计的内容岳父在，越容易出bug。在Statement Level下，目前已发现不少的情况下会造成MySQL的复制问题。
主要是在修改数据使用了某些特定的函数货功能后，出现，
比如：Sleep()函数在有些版本中就不能正确的复制，在存储过程中使用了last_insert_id()函数，可能会使Slave和Master的到不一致的ID，等等。

```
- Mixed Level
```
在Mixed模式下，MySQL会根据执行的每一条具体的SQL语句来区分对待记录的日志形式，也就是在Statement和Row之间选择一种。
除了MySQL认为通过Statement方式可能造成复制过程中Master和Slave之间产生不一致数据。(如特殊Procedure和Funtion的使用，
UUID()函数的使用等特殊情况)时，它会选择ROW的模式来记录变更之外，都会使用Statement方式。
```

###4. redo log 和 bin log
- InnoDB 的 redo log 是固定大小的，比如可以配置为一组 4 个文件，每个文件的大小是 1GB。从头开始写，写到末尾就又回到开头循环写，如下面这个图所示。

![Image text](image/mysql-redo-log.jpg)

- redo的二阶段提交

![Image text](image/mysql-bin-log.png)

```
write pos 是当前记录的位置，一边写一边后移，写到第 3 号文件末尾后就回到 0 号文件开头。
checkpoint 是当前要擦除的位置，也是往后推移并且循环的，擦除记录前要把记录更新到数据文件。
有了 redo log，InnoDB 就可以保证即使数据库发生异常重启，之前提交的记录都不会丢失，这个能力称为 crash-safe。

前面我们讲过，MySQL 整体来看，其实就有两块：一块是 Server 层，它主要做的是 MySQL 功能层面的事情；还有一块是引擎层，负责存储相关的具体事宜。
redo log 是 InnoDB 引擎特有的日志，而 Server 层也有自己的日志，称为 binlog（归档日志）。

因为最开始 MySQL 里并没有 InnoDB 引擎。MySQL 自带的引擎是 MyISAM，但是 MyISAM 没有 crash-safe 的能力，binlog 日志只能用于归档。
而 InnoDB 是另一个公司以插件形式引入 MySQL 的，既然只依靠 binlog 是没有 crash-safe 能力的，
所以 InnoDB 使用另外一套日志系统——也就是 redo log 来实现 crash-safe 能力。

这两种日志有以下三点不同：
1）redo log 是 InnoDB 引擎特有的；binlog 是 MySQL 的 Server 层实现的，所有引擎都可以使用。
2）redo log 是物理日志，记录的是“在某个数据页上做了什么修改”；binlog 是逻辑日志，记录的是这个语句的原始逻辑，比如“给 ID=2 这一行的 c 字段加 1 ”。
3）redo log 是循环写的，空间固定会用完；binlog 是可以追加写入的。“追加写”是指 binlog 文件写到一定大小后会切换到下一个，并不会覆盖以前的日志。
```

###4. undo log
![Image text](image/mysql-undo-log.png)
![Image text](image/mysql-undo-log-transaction.png)
```
InnoDB 里面每个事务有一个唯一的事务 ID，叫作 transaction id。它是在事务开始的时候向 InnoDB 的事务系统申请的，是按申请顺序严格递增的。
而每行数据也都是有多个版本的。每次事务更新数据的时候，都会生成一个新的数据版本，并且把 transaction id 赋值给这个数据版本的事务 ID，记为 row trx_id。
同时，旧的数据版本要保留，并且在新的数据版本中，能够有信息可以直接拿到它。也就是说，数据表中的一行记录，其实可能有多个版本 (row)，每个版本有自己的 row trx_id。

你可能会问，前面的文章不是说，语句更新会生成 undo log（回滚日志）吗？那么，undo log 在哪呢？
上图中的三个虚线箭头，就是 undo log；而 V1、V2、V3 并不是物理上真实存在的，而是每次需要的时候根据当前版本和 undo log 计算出来的。
比如，需要 V2 的时候，就是通过 V4 依次执行 U3、U2 算出来。

在实现上， InnoDB 为每个事务构造了一个数组，用来保存这个事务启动瞬间，当前正在“活跃”的所有事务 ID。“活跃”指的就是，启动了但还没提交。
数组里面事务 ID 的最小值记为低水位，当前系统里面已经创建过的事务 ID 的最大值加 1 记为高水位。
这样，对于当前事务的启动瞬间来说，一个数据版本的 row trx_id，有以下几种可能：
1. 如果落在绿色部分，表示这个版本是已提交的事务或者是当前事务自己生成的，这个数据是可见的；
2. 如果落在红色部分，表示这个版本是由将来启动的事务生成的，是肯定不可见的；
3. 如果落在黄色部分，那就包括两种情况：
    a.  若 row trx_id 在数组中，表示这个版本是由还没提交的事务生成的，不可见；
    b.  若 row trx_id 不在数组中，表示这个版本是已经提交了的事务生成的，可见。
    
InnoDB 利用了“所有数据都有多个版本”的这个特性，实现了“秒级创建快照”的能力。
一个数据版本，对于一个事务视图来说，自己的更新总是可见以外。
```

### 5.主备切换
```
判断备库 B 现在的 seconds_behind_master，如果小于某个值（比如 5 秒）继续下一步，否则持续重试这一步；
把主库 A 改成只读状态，即把 readonly 设置为 true；
判断备库 B 的 seconds_behind_master 的值，直到这个值变成 0 为止；
把备库 B 改成可读写状态，也就是把 readonly 设置为 false；
把业务请求切到备库 B。
```